#!/usr/bin/env python3
"""
Test Environment Setup Script
Creates test database and verifies test environment configuration
"""

import os
import sys
import subprocess
from pathlib import Path
import secrets


def print_header(text):
    """Print formatted header."""
    print(f"\n{'=' * 80}")
    print(f"  {text}")
    print(f"{'=' * 80}\n")


def print_step(text):
    """Print step information."""
    print(f"→ {text}")


def print_success(text):
    """Print success message."""
    print(f"✅ {text}")


def print_error(text):
    """Print error message."""
    print(f"❌ {text}")


def print_warning(text):
    """Print warning message."""
    print(f"⚠️  {text}")


def check_python_version():
    """Check if Python version is 3.11+."""
    print_step("Checking Python version...")
    version = sys.version_info

    if version.major == 3 and version.minor >= 11:
        print_success(f"Python {version.major}.{version.minor}.{version.micro}")
        return True
    else:
        print_error(f"Python 3.11+ required, found {version.major}.{version.minor}.{version.micro}")
        return False


def check_postgresql():
    """Check if PostgreSQL is accessible."""
    print_step("Checking PostgreSQL connection...")

    try:
        result = subprocess.run(
            ['psql', '--version'],
            capture_output=True,
            text=True,
            timeout=5
        )

        if result.returncode == 0:
            version = result.stdout.strip()
            print_success(f"PostgreSQL found: {version}")
            return True
        else:
            print_error("PostgreSQL not found in PATH")
            return False

    except FileNotFoundError:
        print_error("psql command not found. Is PostgreSQL installed?")
        return False
    except subprocess.TimeoutExpired:
        print_error("PostgreSQL check timed out")
        return False


def create_test_database():
    """Create test database."""
    print_step("Creating test database...")

    db_name = "test_multitenant_db"
    db_user = os.getenv('POSTGRES_USER', 'admin')

    commands = [
        f"DROP DATABASE IF EXISTS {db_name};",
        f"CREATE DATABASE {db_name};",
        f"GRANT ALL PRIVILEGES ON DATABASE {db_name} TO {db_user};"
    ]

    try:
        for cmd in commands:
            result = subprocess.run(
                ['psql', '-U', 'postgres', '-c', cmd],
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode != 0:
                print_error(f"Failed to execute: {cmd}")
                print(result.stderr)
                return False

        print_success(f"Test database '{db_name}' created successfully")
        return True

    except subprocess.TimeoutExpired:
        print_error("Database creation timed out")
        return False
    except Exception as e:
        print_error(f"Failed to create database: {e}")
        return False


def generate_test_secrets():
    """Generate test secrets for .env.test."""
    print_step("Generating test secrets...")

    # Generate secure random keys
    encryption_key = secrets.token_urlsafe(32)  # 32 bytes base64 = 44 chars
    jwt_secret = secrets.token_urlsafe(32)

    print_success("Test secrets generated")

    return {
        'ENCRYPTION_KEY': encryption_key,
        'JWT_SECRET_KEY': jwt_secret
    }


def create_env_test_file(secrets_dict):
    """Create .env.test file with test configuration."""
    print_step("Creating .env.test file...")

    env_test_path = Path(__file__).parent / '.env.test'

    content = f"""# Test Environment Configuration
# Generated by setup_test_env.py
# DO NOT use these values in production!

# Test Database
TEST_DATABASE_URL=postgresql+asyncpg://admin:admin123@localhost:5432/test_multitenant_db
DATABASE_URL=postgresql+asyncpg://admin:admin123@localhost:5432/test_multitenant_db

# Test Secrets (auto-generated)
ENCRYPTION_KEY={secrets_dict['ENCRYPTION_KEY']}
JWT_SECRET_KEY={secrets_dict['JWT_SECRET_KEY']}

# CORS (test frontend)
CORS_ALLOWED_ORIGINS=http://localhost:3000,http://127.0.0.1:3000

# Redis (optional for tests, uses in-memory fallback)
REDIS_URL=redis://localhost:6379/1

# SMTP (mock/disabled for tests)
SMTP_HOST=localhost
SMTP_PORT=1025
SMTP_USE_SSL=false
SMTP_USER=test@example.com
SMTP_PASSWORD=testpass
SMTP_FROM_EMAIL=noreply@test.panaceon.com

# Frontend URL (test)
FRONTEND_URL=http://localhost:3000

# Test Mode
TESTING=true
"""

    try:
        with open(env_test_path, 'w') as f:
            f.write(content)

        print_success(f"Created {env_test_path}")
        return True

    except Exception as e:
        print_error(f"Failed to create .env.test: {e}")
        return False


def check_test_dependencies():
    """Check if test dependencies are installed."""
    print_step("Checking test dependencies...")

    required_packages = [
        'pytest',
        'pytest-asyncio',
        'httpx',
        'pytest-cov',
        'faker'
    ]

    missing = []

    for package in required_packages:
        try:
            __import__(package.replace('-', '_'))
        except ImportError:
            missing.append(package)

    if missing:
        print_warning(f"Missing packages: {', '.join(missing)}")
        print("Install with: pip install -r requirements.txt")
        return False
    else:
        print_success("All test dependencies installed")
        return True


def verify_test_setup():
    """Verify test environment is ready."""
    print_step("Verifying test setup...")

    checks = [
        ('Test database accessible', check_test_database_accessible),
        ('Environment variables set', check_env_variables),
    ]

    all_passed = True

    for check_name, check_func in checks:
        try:
            if check_func():
                print_success(check_name)
            else:
                print_error(f"{check_name} - FAILED")
                all_passed = False
        except Exception as e:
            print_error(f"{check_name} - ERROR: {e}")
            all_passed = False

    return all_passed


def check_test_database_accessible():
    """Check if test database is accessible."""
    import asyncio
    from sqlalchemy.ext.asyncio import create_async_engine

    db_url = os.getenv('TEST_DATABASE_URL', 'postgresql+asyncpg://admin:admin123@localhost:5432/test_multitenant_db')

    async def test_connection():
        try:
            engine = create_async_engine(db_url, echo=False)
            async with engine.connect() as conn:
                await conn.execute('SELECT 1')
            await engine.dispose()
            return True
        except Exception as e:
            print(f"  Error: {e}")
            return False

    return asyncio.run(test_connection())


def check_env_variables():
    """Check if required environment variables are set."""
    required_vars = [
        'ENCRYPTION_KEY',
        'JWT_SECRET_KEY',
        'DATABASE_URL'
    ]

    missing = [var for var in required_vars if not os.getenv(var)]

    if missing:
        print(f"  Missing: {', '.join(missing)}")
        return False

    return True


def main():
    """Main setup function."""
    print_header("Panaceon V-06 Test Environment Setup")

    # Load .env.test if it exists
    env_test_path = Path(__file__).parent / '.env.test'
    if env_test_path.exists():
        print_step("Loading .env.test...")
        from dotenv import load_dotenv
        load_dotenv(env_test_path)
        print_success("Environment loaded")

    steps = [
        ("Python Version", check_python_version),
        ("PostgreSQL", check_postgresql),
        ("Test Database", create_test_database),
        ("Test Dependencies", check_test_dependencies),
    ]

    all_passed = True

    for step_name, step_func in steps:
        print_header(f"Step: {step_name}")
        if not step_func():
            all_passed = False
            print_error(f"{step_name} failed")

    # Generate secrets and create .env.test
    print_header("Test Configuration")
    secrets = generate_test_secrets()

    if not create_env_test_file(secrets):
        all_passed = False

    # Final verification
    print_header("Verification")

    # Reload environment with new .env.test
    from dotenv import load_dotenv
    load_dotenv(env_test_path, override=True)

    if not verify_test_setup():
        all_passed = False

    # Print summary
    print_header("Setup Summary")

    if all_passed:
        print_success("Test environment ready!")
        print("\nNext steps:")
        print("  1. Review .env.test configuration")
        print("  2. Run tests: pytest")
        print("  3. Or use: python run_tests.py --all")
        print("")
        return 0
    else:
        print_error("Setup completed with errors")
        print("\nPlease fix the errors above and run this script again.")
        print("")
        return 1


if __name__ == '__main__':
    sys.exit(main())
